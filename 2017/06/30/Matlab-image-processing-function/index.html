<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记性越来越差，只能把学过的东西记下来，不然白学"><title>Matlab图像处理重要函数 | 老姜</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Matlab图像处理重要函数</h1><a id="logo" href="/.">老姜</a><p class="description">数据挖掘 | 编程 | 学习笔记</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Matlab图像处理重要函数</h1><div class="post-meta">Jun 30, 2017<span> | </span><span class="category"><a href="/categories/Matlab/">Matlab</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h3 id="bwboundaries"><a href="#bwboundaries" class="headerlink" title="bwboundaries"></a>bwboundaries</h3><p>一个强大的函数<br>bwboundaries Trace region boundaries in binary image.跟踪二值图像的边界</p>
<h2 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h2><p>cell元包是matlab中提供的一种数据类型，功能强大。</p>
<h3 id="关于cell的创建："><a href="#关于cell的创建：" class="headerlink" title="关于cell的创建："></a>关于cell的创建：</h3><ol>
<li>跟一般创建举证一样，直接使用C = {A B D E}这种形式，不过这里把”<a href=""></a>“改成了}”{}”</li>
<li>使用cell创建cell,C= {C1 C2},这里C1和C2都是cell类型,直接把C1 C2作为一个cell得到的C3是一个1x2的cell数组；使用C3 = <a href="">C1 C2</a>,是使用C1和C2的内容来创建cell数组</li>
<li>使用cell函数，A=cell(2,2),创建一个空的2x2的cell矩阵.</li>
</ol>
<h3 id="关于cell的访问"><a href="#关于cell的访问" class="headerlink" title="关于cell的访问:"></a>关于cell的访问:</h3><ol>
<li>X = C(s)使用这种”()”形式的返回的是cell类型;</li>
<li>X = C{s}使用这种”{}”形式的返回的是cell中的内容其他的基本上与通常的数组.矩阵访问一样了;</li>
<li>A{1,1}(2,3:end)访问的是A中的第一个cell里面内容的第2行的第三个元素以后的所有元素;</li>
<li>A{1,3}.name访问的是A中的A{1,3}cell里面结构的name值;</li>
<li>cell的图形化显示使用命令cellplot(A)即可.</li>
</ol>
<h3 id="关于cell的删除"><a href="#关于cell的删除" class="headerlink" title="关于cell的删除:"></a>关于cell的删除:</h3><pre><code>1.cell(1)=[]删除第一个cell,不能使用cell{1}=[],这是把第一个cell内容置空没有删除
&gt;&gt;C4={C1,C2,C3}
C4 =
    {3x2 cell}    {3x3 cell}    {3x1 cell}
&gt;&gt; C4(1)=[]
C4 =
    {3x3 cell}    {3x1 cell}
2.cell(:)=[]删除所有的cell,其他的删除一次类推
&gt;&gt; C4(:)=[]
C4 =
     {}
B={[1;2]}
这就定义了一个cell型的变量B，里面保存的是一个矩阵[1;2]
要引用里面的数据只要在大括号里写上对应的下标即可，如
B{1}
</code></pre><h3 id="cell-fun"><a href="#cell-fun" class="headerlink" title="cell fun"></a>cell fun</h3><p> cellfun Apply a function to each cell of a cell array.<br>A = cellfun(FUN, C) applies the function specified by FUN to the<br>contents of each cell of cell array C, and returns the results in<br>the array A.</p>
<h3 id="struct-to-cell-cell-to-mat"><a href="#struct-to-cell-cell-to-mat" class="headerlink" title="struct to cell; cell to mat"></a>struct to cell; cell to mat</h3><p>please check struct2cell cell2mat</p>
<h3 id="下面我们给B再加个元素，我们可以这样定义"><a href="#下面我们给B再加个元素，我们可以这样定义" class="headerlink" title="下面我们给B再加个元素，我们可以这样定义"></a>下面我们给B再加个元素，我们可以这样定义</h3><pre><code>B(2)={&apos;hello&apos;}
也可以利用引用的方法定义
B{2}=&apos;hello&apos;
第二种方法比第一种方法更方便所以更常用。
这样B就有两个元素了，B(1)是{[1;2]}，B(2)是{&apos;hello&apos;}，每个元素都是cell型的（注意和B{1}、B{2}的区别，B{1}是[1;2]，B{2}是&apos;hello’)
</code></pre><h3 id="奇偶个数"><a href="#奇偶个数" class="headerlink" title="奇偶个数"></a>奇偶个数</h3><pre><code>even = length(find(mod(data, 2) == 0))
odd = length(find(mod(data, 2) == 1))
</code></pre><h2 id="连通域分析"><a href="#连通域分析" class="headerlink" title="连通域分析"></a>连通域分析</h2><h3 id="度量连通域的属性－－regionprops"><a href="#度量连通域的属性－－regionprops" class="headerlink" title="度量连通域的属性－－regionprops"></a>度量连通域的属性－－regionprops</h3><p>regionprops Measure properties of image regions.</p>
<h3 id="提取连通区域的特征，和计算属性"><a href="#提取连通区域的特征，和计算属性" class="headerlink" title="提取连通区域的特征，和计算属性"></a>提取连通区域的特征，和计算属性</h3><p>使用三个函数分别是：bwlabel、bwboundaries、regionprops<br>首先使用bwlabel 对连通区域打标签，然后可以使用region props计算连通区域的一些属性，其次bwboundaries可以用来提取连通区域的边界。可以联合regionprops和bwboundaries计算特征。<br>bwlabel和find使用可以提取每个连通区域的坐标，bwboundaries可以提取边界的坐标。</p>
<h3 id="regionprops—属性"><a href="#regionprops—属性" class="headerlink" title="regionprops—属性"></a>regionprops—属性</h3><p>‘Area’：是标量，计算出在图像各个区域中像素总个数。注意：这个数值可能与由函数 bwarea 计算的值有轻微的不同。对于这样一个数值，我们可以使用它除以整个图像区域的像素个数而得到斑纹比例，可以作为模式识别的候选特征，并且这个特征是仿射不变的。<br>‘BoundingBox’：是1行ndims(L)<em>2列的向量，即包含相应区域的最小矩形。BoundingBox 形式为 <a href="">ul_corner width</a>，这里 ul_corner 以 <a href="">x y z …</a> 的坐标形式给出边界盒子的左上角、boxwidth 以 <a href="">x</a>_width y_width …] 形式指出边界盒子沿着每个维数方向的长度。本例的各部分区域最小矩形如下图！注意：请在这熟悉一下函数rectangle的使用方法。<br>‘Centroid’：是1行ndims(L)列的向量，给出每个区域的质心（重心）。<strong>注意：Centroid 的第一个元素是重心水平坐标（x坐标）、第二个元素是重心垂直坐标（y坐标）。</strong>Centroid 所有其它元素则按照维顺序排列。下图采用以中心为圆心的小圆来演示质心检测的效果：<br> ‘MajorAxisLength’：是标量，与区域具有相同标准二阶中心矩的椭圆的长轴长度（像素意义下）。本属性只支持二维标注矩阵。<br>‘MinorAxisLength’：是标量，与区域具有相同标准二阶中心矩的椭圆的短轴长度（像素意义下）。本属性只支持二维标注矩阵。<br>‘Eccentricity’：是标量，与区域具有相同标准二阶中心矩的椭圆的离心率（可作为特征）。本属性只支持二维标注矩阵。<br><strong>‘Orientation’：是标量，与区域具有相同标准二阶中心矩的椭圆的长轴与x轴的交角（度）。本属性只支持二维标注矩阵。</strong><br>我们可以考察离心率的变化趋势，得到对于整个区域中的各区域的似圆性如何的大致感觉，比如下图是12个区域的离心率变化情形：<br>由上图可以看出区域整体的似圆性并不好，实际上可以考虑使用离心率向量作为一个模式识别的特征！！<br>‘Image’：二值图像，与某区域具有相同大小的逻辑矩阵。你可以用这个属性直接将每个子区域提取出来，然后再作相应的处理！<br> ‘FilledImage’：与上相同，唯一区别是这是个做了填充的逻辑矩阵！<br>本例中和上面的没有区别，只有区域有空洞时才有明显差别。<br>‘FilledArea’：是标量，填充区域图像中的 on 像素个数。<br>‘ConvexHull’：是p行2列的矩阵，包含某区域的最小凸多边形。此矩阵的每一行存储此多边形一个顶点的xy坐标。此属性只支持2维标注矩阵。例如：本例中的所有子区域的最小凸多边形图形如下图<br>看看第2个区域的大图:<br>‘ConvexImage’：二值图像，用来画出上述的区域最小凸多边形。同时此凸包内的像素均打开，图像尺寸和此区域对应边界矩形相同。此属性只支持2维标注矩阵。注意：<strong>此处函数roipoly很有用！</strong><br>‘ConvexArea’：是标量，填充区域凸多边形图像中的 on 像素个数。<br>‘EulerNumber’：是标量，几何拓扑中的一个拓扑不变量–欧拉数，等于图像中目标个数减去这些目标中空洞的个数。此属性只支持2维标注矩阵。本例中的欧拉数均为1。<br>‘Extrema’：8行2列矩阵，八方向区域极值点。矩阵每行存储这些点的xy坐标，向量格式为 <a href="">top-left top-right right-top right-bottom bottom-right bottom-left left-bottom left-top</a>。此属性只支持2维标注矩阵。<br>‘EquivDiameter’：是标量，等价直径：与区域具有相同面积的圆的直径。计算公式为：sqrt(4</em>Area/pi)。. 此属性只支持2维标注矩阵。<br>‘Solidity’：是标量，同时在区域和其最小凸多边形中的像素比例。计算公式为：Area/ConvexArea，这也是个仿射特征，实际上反映出区域的固靠性程度。此属性只支持2维标注矩阵。<br>‘Extent’：是标量，同时在区域和其最小边界矩形中的像素比例。计算公式为：Area除以边界矩形面积，这也是个仿射特征，实际上反映出区域的扩展范围程度。此属性只支持2维标注矩阵。不再给出计算结果！！<br>‘PixelIdxList’：p元向量，存储区域像素的索引下标。<br>‘PixelList’：p行ndims(L)列矩阵，存储上述索引对应的像素坐标。<br>支持类：输入的标注矩阵L可以有任意的数值类型。</p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><pre><code>[r, c] = find(X);
r 为行索引就是第几行，y坐标
c为列索引就是第几列，x坐标
</code></pre><h3 id="重复一行向量形成n行矩阵—repmat-Replicate-and-tile-an-array"><a href="#重复一行向量形成n行矩阵—repmat-Replicate-and-tile-an-array" class="headerlink" title="重复一行向量形成n行矩阵—repmat Replicate and tile an array."></a>重复一行向量形成n行矩阵—repmat Replicate and tile an array.</h3><pre><code>repmat(x,[2,1])
</code></pre><h3 id="加法－sum"><a href="#加法－sum" class="headerlink" title="加法－sum"></a>加法－sum</h3><p>按行加<br>    sum(x,2)<br>按列加<br>    sum(x,1)</p>
<h3 id="计算直方图频数，频次计算－tabulate"><a href="#计算直方图频数，频次计算－tabulate" class="headerlink" title="计算直方图频数，频次计算－tabulate"></a>计算直方图频数，频次计算－tabulate</h3><p>tabulate Frequency table.<br>这个函数计算每个数的频次，返回的是一个table</p>
<h3 id="获取像素值－－impel"><a href="#获取像素值－－impel" class="headerlink" title="获取像素值－－impel"></a>获取像素值－－impel</h3><p>impixel Pixel color values.<br>You can also specify the pixels noninteractively, using these syntaxes:<br> P = impixel(I,C,R)<br>R and C are equal-length vectors specifying the coordinates<br>of the pixels whose RGB values are returned in P. The k-th<br>row of P contains the RGB values for the pixel (R(k),C(k)).<br>输入坐标的，行列向量，放回三通道的像素值，如果输入图像I是灰度图像的话，那么返回的三通道像素值是一样的，只需要取一列像素的值就好了。</p>
<h3 id="NaN-变量在图像处理中的妙用"><a href="#NaN-变量在图像处理中的妙用" class="headerlink" title="NaN 变量在图像处理中的妙用"></a>NaN 变量在图像处理中的妙用</h3><p>计算感兴趣区域（ROI）的灰度共生矩阵时，因为ROI区域不时矩形，所以不好直接计算，故而把非ROI区域的像素设为NaN即可把计算ROI区域的灰度共生矩阵，转化为计算ROI区域最大包围矩阵的灰度共生矩阵，解决计算难题。</p>
<h4 id="把图像中非ROI区域设为NaN"><a href="#把图像中非ROI区域设为NaN" class="headerlink" title="把图像中非ROI区域设为NaN"></a>把图像中非ROI区域设为NaN</h4><p>首先把图像转换为double精度<br>    newimg = immultiply(bwimg, srcimg);<br>    newimg2 = double(newimg);％这里的newimg为原图和掩模相乘后的图像<br>‘<br>    这样并不会改变像素值<br>    然后，newimg2(newimg2 == 0) = NaN;</p>
<h3 id="包围盒BoundingBox"><a href="#包围盒BoundingBox" class="headerlink" title="包围盒BoundingBox"></a>包围盒BoundingBox</h3><pre><code>status = regionprops(L,&apos;BoundingBox&apos;)
</code></pre><p>然后使用imcrop剪切图像进行灰度共生矩阵计算。</p>
<h3 id="graycomatrix-灰度共生矩阵"><a href="#graycomatrix-灰度共生矩阵" class="headerlink" title="graycomatrix 灰度共生矩阵."></a>graycomatrix 灰度共生矩阵.</h3><p>使用方式<br>    GLCMS = graycomatrix(I,PARAM1,VALUE1,PARAM2,VALUE2,…)<br>参数：</p>
<ol>
<li>’Offset’   ： 就是定义所谓的角度，可以是一个矩阵例如<code>offsets = [0 1; -1 1;-1 0;-1 -1];</code></li>
<li>’NumLevels’ ： 定义灰度共生矩阵的灰度级</li>
<li><p>’GrayLimits’  ： A two-element vector, <code>[LOW HIGH]</code>, that specifies how the values in I are scaled into gray levels.</p>
</li>
<li><p>’Symmetric’ : 设置数值是否对称，例如2，1 和 1，2是否一样，默认是false</p>
</li>
</ol>
<h2 id="在原图中画图／做标记"><a href="#在原图中画图／做标记" class="headerlink" title="在原图中画图／做标记"></a>在原图中画图／做标记</h2><pre><code>figure,imshow(bwimg);
axis on
hold on
plot(centx,centy,&apos;r+&apos;);
</code></pre><h2 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 sort"></a>排序 sort</h2><p> sort   Sort in ascending or descending order.<br><code>[Y,I]</code>= sort(X,DIM,MODE) also returns an index matrix I.<br>If X is a vector, then Y = X(I).</p>
<h2 id="去除面积小于p的区域"><a href="#去除面积小于p的区域" class="headerlink" title="去除面积小于p的区域"></a>去除面积小于p的区域</h2><p>   BW2 = bwareaopen(BW,P) removes from a binary image all connected<br>components (objects) that have fewer than P pixels, producing another<br>binary image BW2.  This operation is known as an area opening.  The<br>default connectivity is 8 for two dimensions, 26 for three dimensions,<br>and CONNDEF(NDIMS(BW),’maximal’) for higher dimensions. </p>
<p>BW2 = bwareaopen(BW,P,CONN) specifies the desired connectivity.  CONN<br>may have the following scalar values</p>
<h2 id="感兴趣区域分割"><a href="#感兴趣区域分割" class="headerlink" title="感兴趣区域分割"></a>感兴趣区域分割</h2><p>roipoly 选取多边形的（ploygonal）感兴趣区域。<br>返回一个二值化的掩模。<br> BW = roipoly 创建一个与当前图像相关联的交互式的多边形工具。</p>
<h2 id="开根号函数-nthroot"><a href="#开根号函数-nthroot" class="headerlink" title="开根号函数 nthroot"></a>开根号函数 nthroot</h2><p>nthroot Real n-th root of real numbers.</p>
<p>nthroot(X, N) returns the real Nth root of the elements of X.<br>Both X and N must be real, and if X is negative, N must be an odd integer.</p>
<p>Class support for inputs X, N:<br>   float: double, single </p>
<h2 id="log算子"><a href="#log算子" class="headerlink" title="log算子"></a>log算子</h2><p>BW = edge(I,’log’) detect edges using the Laplacian of Gaussian (‘log’) method. This method finds edges by looking for zero-crossings after filtering I with a Laplacian of Gaussian filter.<br>BW = edge(I,’log’,threshold) return all edges that are stronger than threshold. If you do not specify threshold, or is you specify empty brackets (<code>[])</code>, edge chooses the value automatically.<br>BW = edge(I,’log’,threshold,sigma) specify sigma, the standard deviation of the ‘log’ filter. The default sigma is 2; the size of the filter is n-by-n, where n=ceil(sigma<em>3)</em>2+1.</p>
<h2 id="ceil-小数取整"><a href="#ceil-小数取整" class="headerlink" title="ceil 小数取整"></a>ceil 小数取整</h2><h2 id="读／写csv"><a href="#读／写csv" class="headerlink" title="读／写csv"></a>读／写csv</h2><p>csvread<br>csvwrite<br>    imwrite(I, ‘TEST.jpg’,’jpeg’,’bitdepth’,16);</p>
<h2 id="读取文件夹下的文件—dir"><a href="#读取文件夹下的文件—dir" class="headerlink" title="读取文件夹下的文件—dir"></a>读取文件夹下的文件—dir</h2><p>星号可以用进行正则匹配<br>    dList=dir(‘D:*.PNG’);<br>    N=length(dList); %Number of Images<br>    for i=1:N<br>        Image_data{i}=imread([‘D:\’,dList(i).name]);<br>        subplot(2,2,i)<br>        imshow(Image_data{i})<br>    end</p>
<h2 id="计算程序所用时间"><a href="#计算程序所用时间" class="headerlink" title="计算程序所用时间"></a>计算程序所用时间</h2><p>toc Read the stopwatch timer.<br>TIC and toc functions work together to measure elapsed time.<br>toc, by itself, displays the elapsed time, in seconds, since<br>the most recent execution of the TIC command.</p>
<p>T = toc; saves the elapsed time in T as a double scalar.</p>
<p>toc(TSTART) measures the time elapsed since the TIC command that<br>generated TSTART.</p>
<p>Example: Measure the minimum and average time to compute a sum<br> of Bessel functions.</p>
<p>  REPS = 1000; minTime = Inf; nsum = 10;<br>  tic;<br>  for i=1:REPS<br>tstart = tic;<br>sum = 0; for j=1:nsum, sum = sum + besselj(j,REPS); end<br>telapsed = toc(tstart);<br>minTime = min(telapsed,minTime);<br>  end<br>  averageTime = toc/REPS;</p>
<p>See also tic, cputime.</p>
<h3 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h3><p>min    Smallest component.<br>For vectors, min(X) is the smallest element in X. For matrices,<br>min(X) is a row vector containing the minimum element from each<br>column. For N-D arrays, min(X) operates along the first<br>non-singleton dimension.</p>
<h3 id="凸包convhull"><a href="#凸包convhull" class="headerlink" title="凸包convhull"></a>凸包convhull</h3><h2 id="字符串中提取数字"><a href="#字符串中提取数字" class="headerlink" title="字符串中提取数字"></a>字符串中提取数字</h2><p>str=’ajsk123sjkl’<br>A=isstrprop(str,’digit’);<br>B=str(A);<br>C=str2num(B)</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://zhiqiang.studio/2017/06/30/Matlab-image-processing-function/" data-id="cj4kwr0fb0006hngp0gnksdk5" class="article-share-link">分享</a><div class="tags"><a href="/tags/Matlab/">Matlab</a></div><div class="post-nav"><a href="/2017/06/30/70. Climbing Stairs/" class="pre">70. Climbing Stairs -- 动态规划、斐波那契数列</a><a href="/2017/06/30/R-language-notes/" class="next">R语言学习笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode刷题/">Leetcode刷题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Matlab/">Matlab</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/R语言/">R语言</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/easy/" style="font-size: 15px;">easy</a> <a href="/tags/Matlab/" style="font-size: 15px;">Matlab</a> <a href="/tags/R语言/" style="font-size: 15px;">R语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/01/108. Convert Sorted Array to Binary Search Tree/">108. Convert Sorted Array to Binary Search Tree</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/01/121. Best Time to Buy and Sell Stock/">121. Best Time to Buy and Sell Stock</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/01/202. Happy Number/">202. Happy Number</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/70. Climbing Stairs/">70. Climbing Stairs -- 动态规划、斐波那契数列</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/Matlab-image-processing-function/">Matlab图像处理重要函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/R-language-notes/">R语言学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/Hexo-trick/">Hexo 技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hexo介绍/">hexo快速开始</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/u012925804" title="My CSDN" target="_blank">My CSDN</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">老姜.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>