<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记性越来越差，只能把学过的东西记下来，不然白学"><title>爬虫 http协议 | 老姜工作室</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">爬虫 http协议</h1><a id="logo" href="/.">老姜工作室</a><p class="description">数据挖掘 | 编程 | 学习笔记</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">爬虫 http协议</h1><div class="post-meta">Jul 20, 2017<span> | </span><span class="category"><a href="/categories/爬虫/">爬虫</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Python-爬虫"><span class="toc-number">1.</span> <span class="toc-text">Python 爬虫</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#主要请求方式"><span class="toc-number">1.1.</span> <span class="toc-text">主要请求方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器获取信息的过程"><span class="toc-number">1.2.</span> <span class="toc-text">浏览器获取信息的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-协议"><span class="toc-number">1.3.</span> <span class="toc-text">http 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">1.3.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL"><span class="toc-number">1.4.</span> <span class="toc-text">URL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL包含以下几部分"><span class="toc-number">1.4.1.</span> <span class="toc-text">URL包含以下几部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-请求-request"><span class="toc-number">1.5.</span> <span class="toc-text">HTTP 请求 request</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-请求"><span class="toc-number">1.6.</span> <span class="toc-text">http 请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http请求-响应的步骤"><span class="toc-number">1.7.</span> <span class="toc-text">http请求/响应的步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程："><span class="toc-number">1.7.1.</span> <span class="toc-text">例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get和post的区别"><span class="toc-number">1.8.</span> <span class="toc-text">get和post的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get请求"><span class="toc-number">1.9.</span> <span class="toc-text">get请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#post请求"><span class="toc-number">1.10.</span> <span class="toc-text">post请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态码"><span class="toc-number">1.11.</span> <span class="toc-text">状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久连接"><span class="toc-number">1.12.</span> <span class="toc-text">持久连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#注意："><span class="toc-number">1.12.0.0.1.</span> <span class="toc-text">注意：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#会话跟踪"><span class="toc-number">1.13.</span> <span class="toc-text">会话跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#会话跟踪常用的方法"><span class="toc-number">1.13.0.1.</span> <span class="toc-text">会话跟踪常用的方法:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跨站攻击"><span class="toc-number">1.14.</span> <span class="toc-text">跨站攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何防范-CSRF-攻击？可以注意以下几点："><span class="toc-number">1.14.1.</span> <span class="toc-text">如何防范 CSRF 攻击？可以注意以下几点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用："><span class="toc-number">1.15.</span> <span class="toc-text">引用：</span></a></li></ol></li></ol></div></div><div class="post-content"><h1 id="Python-爬虫"><a href="#Python-爬虫" class="headerlink" title="Python 爬虫"></a>Python 爬虫</h1><p>数据分析+爬虫 </p>
<h2 id="主要请求方式"><a href="#主要请求方式" class="headerlink" title="主要请求方式"></a>主要请求方式</h2><p>利用 HTTP 从网络服务获取信息有四种方式：</p>
<p>• GET</p>
<p>• POST</p>
<p>• PUT</p>
<p>• DELETE</p>
<p><strong>GET 就是你在浏览器中输入网址浏览网站所做的事情</strong>。 当你访问 <a href="http://freegeoip.net/" target="_blank" rel="external">http://freegeoip.net/</a> json/50.78.253.58 时，就会使用 GET 方法。可以想象成 GET 在说：“喂， 网络服务器， 请按 照这个网址给我信息。”</p>
<p><strong>POST 基本就是当你填写表单或提交信息到网络服务器的后端程序时所做的事情。</strong>每次当你 登录网站的时候，就是通过用户名和（有可能加密的）密码发起一个 POST 请求。如果你用 API 发起一个 POST 请求，相当于说“请把信息保存到你的数据库里”。</p>
<p>PUT 在网站交互过程中不常用， 但是在 API 里面有时会用到。 PUT 请求用来更新一个对象 或信息。例如， API 可能会要求用 POST 请求创建新用户，<strong>但是如果你要更新老用户的邮箱 地址，就要用 PUT 请求了。</strong> </p>
<p>用于删除一个对象。例如，如果我们向 <a href="http://myapi.com/user/23" target="_blank" rel="external">http://myapi.com/user/23</a> 发出一个 DELETE 请 求，就会删除 ID 号是 23 的用户。 DELETE 方法在公共 API 里面不常用，它们主要用于创建 信息，不能随便让一个用户去删掉数据库的信息。但是，和 PUT 方法一样， DELETE 方法也 值得了解一下。</p>
<p>DELETE</p>
<p>虽然在 HTTP 规范里还有一些信息处理方式，但是这四种基本是你使用 API 过程中可能遇 到的全部。</p>
<h2 id="浏览器获取信息的过程"><a href="#浏览器获取信息的过程" class="headerlink" title="浏览器获取信息的过程"></a>浏览器获取信息的过程</h2><p>可以把这个过程比喻成寄快递的过程：</p>
<ol>
<li>电脑发送请求头和消息体，请求头包含自己的mac地址和服务器的ip地址（相当于快递单），消息体包含请求的内容（相当于快递内容）。</li>
<li>本地路由器收到电脑发出的请求头和消息体，然后盖上自己的ip地址（相当于寄件人的地址），发给服务器。</li>
<li>服务器读取请求头中的目标端口（默认是80，端口看成房子门牌号，ip看成街道地址），然后把它传给对应的服务器应用。</li>
<li>服务器收到一串数据，知道是什么类型请求，请求什么数据。</li>
<li>服务器把请求数据发给浏览器。</li>
</ol>
<h2 id="http-协议"><a href="#http-协议" class="headerlink" title="http 协议"></a>http 协议</h2><p>http协议是服务器和客户端直接传输超文本的协议。定义了web客户端如何从web服务器请求web页面，以及web服务器如何把web页面传给客户端。</p>
<p>http定义了请求、响应模型，客户端向服务器发送了一个请求报文，请求报文包含：请求的方法、URL、协议版本、请求头部和请求数据（五个部分）。</p>
<p>服务器以一个<em>状态行为</em>作为响应，响应的内容包括：协议的版本、成功或错误代码、服务器信息、响应头部和响应数据（五个部分）。</p>
<p>客户端——–请求———&gt;服务器；<br>服务器&lt;——–响应———-客户端。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。</p>
<p>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
<p>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，<em>则它必须重传</em>，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。</p>
<h3 id="URL包含以下几部分"><a href="#URL包含以下几部分" class="headerlink" title="URL包含以下几部分"></a>URL包含以下几部分</h3><ol>
<li>协议部分：http</li>
<li>域名部分：www.sohu.com</li>
<li>端口部分：不是必须的</li>
<li>虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。</li>
<li>文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。例如<code>http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</code></li>
<li>锚部分：不是必须</li>
<li>参数部分：从‘？’开始到‘#’为止直接的部分。又称搜索部分、查询部分。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li>
</ol>
<h2 id="HTTP-请求-request"><a href="#HTTP-请求-request" class="headerlink" title="HTTP 请求 request"></a>HTTP 请求 request</h2><p>http请求包含以下格式：<br>请求行（request line），请求头部（request head），空行和请求数据。<br><img src="pachong-learning/http_request.png" alt=""><br>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。</p>
<h2 id="http-请求"><a href="#http-请求" class="headerlink" title="http 请求"></a>http 请求</h2><p>http包含多种请求方法，就是说这些方法都是请求，有get请求，post请求，反正都是请求，注意理解的时候不要忘记加请求这两个字。</p>
<p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<ul>
<li>GET     请求<em>指定的</em>页面信息，并返回<em>实体主体</em>。</li>
<li>HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于<em>获取报头</em></li>
<li>POST     向指定资源<em>提交数据</em>进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>
<li>PUT     从客户端向服务器传送的数据<em>取代指定的文档的内容</em>。</li>
<li>DELETE      请求服务器<em>删除指定的页面</em>。</li>
<li>CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的<em>代理服务器</em>。</li>
<li>OPTIONS     允许客户端<em>查看</em>服务器的<em>性能</em>。</li>
<li>TRACE     回显服务器收到的请求，主要用于<em>测试或诊断</em>。</li>
</ul>
<p>总结一下就是，get请求用于请求页面信息，head请求用于获取报头，post请求用于提交数据，普通请求用于传输数据，其他的可以看上面。</p>
<h2 id="http请求-响应的步骤"><a href="#http请求-响应的步骤" class="headerlink" title="http请求/响应的步骤"></a>http请求/响应的步骤</h2><ol>
<li><strong>客户端连接到web服务器</strong>：例如浏览器与web服务器的端口建立一个tcp连接。</li>
<li><strong>发送http请求</strong>：通过tcp套接字，客户端向web服务器发送一个请求报文，报文由：请求行、请求头、空行和请求数据四部分组成。</li>
<li><strong>服务器接受请求并返回http响应</strong>：web服务器解析请求，定位请求资源。web服务器将资源副本写到tcp套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据四部分组成。</li>
<li><strong>释放连接TCP连接</strong>：若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li>
<li><p>客户端浏览器解析HTML内容：</p>
<ul>
<li>客户端首先解析<strong>状态行</strong> ：查看请求是否成功的状态码。</li>
<li>解析每个响应头：响应头告知以下为若干个字节的HTML文档，和文档的字符集。</li>
<li>浏览器读取响应数据HTML：根据HTML语法对其进行格式化，显示。</li>
</ul>
</li>
</ol>
<h3 id="例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程："><a href="#例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：" class="headerlink" title="例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程："></a>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</h3><p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址（解析ip）;</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接（建立tcp连接）;</p>
<p>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p>
<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p>
<p>5、释放 TCP连接;</p>
<p>6、浏览器将该 html 文本并显示内容;</p>
<h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><p>GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p>
<p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，</p>
<h2 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h2><p>get不需要带www.sohu.com（域名）<br>GET用于信息获取，而且应该是安全的 和 幂等的。</p>
<p>所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，<strong>就像数据库查询一样</strong>，不会修改，增加数据，不会影响资源的状态。</p>
<p>幂等的意味着对同一URL的多个请求应该返回同样的结果。</p>
<h2 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h2><p>POST表示可能修改变服务器上的资源的请求。</p>
<p>注意:</p>
<p>GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制<br>理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制<br>参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在URL里，一个在 HTTP 包的包体里</p>
<p>HTTP 协议中规定 POST 提交的数据必须在 body 部分中，但是协议中没有规定数据使用哪种编码方式或者数据格式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>200 OK 客户端请求成功</p>
<p>301 Moved Permanently 请求永久重定向<br>302 Moved Temporarily 请求临时重定向<br>304 Not Modified 文件未修改，可以直接使用缓存的文件。</p>
<p>400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。<br>401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因<br>404 Not Found 请求的资源不存在，例如，输入了错误的URL</p>
<p>500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。<br>503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</p>
<h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p>我们知道 HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。</p>
<p>在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 “Connection: close” 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。</p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ul>
<li><p>HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。</p>
</li>
<li><p>HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。</p>
</li>
<li><p>HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive没能改变这个结果。另外，Keep-Alive也不能保证客户端和服务器之间的连接一定是活跃的，在HTTP1.1版本中也如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于Keep-Alive的保持连接特性，否则会有意想不到的后果。</p>
</li>
<li><p>使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1. 判断传输数据是否达到了Content-Length 指示的大小；2. 动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束，详见这里。什么是 chunked 分块传输呢？下面我们就来介绍。</p>
</li>
</ul>
<h2 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h2><ol>
<li>什么是会话？</li>
</ol>
<p>客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。</p>
<ol>
<li>什么是会话跟踪？</li>
</ol>
<p>会话跟踪指的是<strong>对同一个用户</strong>对服务器的连续的请求和接受响应<strong>的监视</strong>。</p>
<ol>
<li>为什么需要会话跟踪？</li>
</ol>
<p>浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。</p>
<h4 id="会话跟踪常用的方法"><a href="#会话跟踪常用的方法" class="headerlink" title="会话跟踪常用的方法:"></a>会话跟踪常用的方法:</h4><ul>
<li>URL重写</li>
</ul>
<p>URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。</p>
<ul>
<li>隐藏表单域</li>
</ul>
<p>将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示</p>
<ul>
<li>Cookie</li>
</ul>
<p>Cookie是<strong>Web服务器发送给客户端</strong>的一小段信息，<strong>客户端请求时可以读取该信息发送到服务器端</strong>，进而<strong>进行用户的识别</strong>。对于客户端的每次请求，服务器都会将Cookie发送到客户端,<strong>在客户端可以进行保存,以便下次使用</strong>。</p>
<p>客户端可以采用两种方式来保存这个Cookie对象，一种方式是保存在<strong>客户端内存中，称为临时Cookie</strong>，浏览器关闭后这个Cookie对象将消失。另外一种方式是保存在客户机的<strong>磁盘上，称为永久Cookie</strong>。以后客户端只要访问该网站，就会将这个Cookie再次发送到服务器上，前提是这个Cookie在有效期内，这样就实现了对客户的跟踪。</p>
<p>Cookie是可以被禁止的。</p>
<ul>
<li>Session:</li>
</ul>
<p>还是不知道干嘛用的？</p>
<p>每一个用户都有一个不同的session，各个用户之间是不能共享的，是每个用户所独享的，在<strong>session中可以存放信息。</strong></p>
<p>在服务器端会创建一个session对象，产生一个sessionID来标识这个session对象，然后将<strong>这个sessionID放入到Cookie中发送到客户端</strong>，下一次访问时，<strong>sessionID会发送到服务器，在服务器端进行识别不同的用户。</strong></p>
<p>Session的实现依赖于Cookie，如果Cookie被禁用，那么session也将失效</p>
<h2 id="跨站攻击"><a href="#跨站攻击" class="headerlink" title="跨站攻击"></a>跨站攻击</h2><p>引用：<a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="external">https://hit-alibaba.github.io/interview/basic/network/HTTP.html</a></p>
<p>CSRF（Cross-site request forgery，跨站请求伪造）</p>
<p>CSRF(XSRF) 顾名思义，是伪造请求，冒充用户在站内的正常操作。</p>
<p>例如，一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问：</p>
<p>  <code>http://example.com/bbs/create_post.php?title=标题&amp;content=内容</code><br>那么，我们只需要在论坛中发一帖，包含一链接：</p>
<p>  <code>http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈</code><br>  只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。</p>
<h3 id="如何防范-CSRF-攻击？可以注意以下几点："><a href="#如何防范-CSRF-攻击？可以注意以下几点：" class="headerlink" title="如何防范 CSRF 攻击？可以注意以下几点："></a>如何防范 CSRF 攻击？可以注意以下几点：</h3><ul>
<li><p>关键操作只接受POST请求</p>
</li>
<li><p>验证码</p>
<p>CSRF攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。</p>
<p>但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。</p>
</li>
<li><p>检测 Referer</p>
</li>
</ul>
<p>常见的互联网页面与页面之间是存在联系的，比如你在www.baidu.com应该是找不到通往www.google.com的链接的，再比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的 Referer 中</p>
<p>通过检查Referer的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到Referer的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击。</p>
<ul>
<li>Token</li>
</ul>
<p>目前主流的做法是使用 Token 抵御 CSRF 攻击。下面通过分析 CSRF 攻击来理解为什么 Token 能够有效</p>
<p>CSRF攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止CSRF攻击。</p>
<p>另一个更通用的做法是保持原有参数不变，另外添加一个参数Token，其值是随机的。这样攻击者因为不知道Token而无法构造出合法的请求进行攻击。</p>
<p>Token 使用原则</p>
<p>Token 要足够随机————只有这样才算不可预测<br>Token 是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度<br>Token 要注意保密性————敏感操作使用 post，防止 Token 出现在 URL 中<br>注意：过滤用户输入的内容不能阻挡 csrf，我们需要做的是过滤请求的来源。</p>
<h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><p>[1] python网络数据采集</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://zhiqiang.studio/2017/07/20/pachong-learning/" data-id="cjha5ks08004q4jhw6w0juqr9" class="article-share-link">分享</a><div class="tags"><a href="/tags/http/">http</a></div><div class="post-nav"><a href="/2017/07/21/pachong2/" class="pre">爬虫背景调研学习笔记</a><a href="/2017/07/20/mult-plot/" class="next">python 画多个子图</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode刷题/">Leetcode刷题</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Matlab/">Matlab</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/R语言/">R语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/matplotlib/">matplotlib</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/py/">py</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/sklearn/">sklearn</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">spark</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tensorflow/">tensorflow</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据分析/">数据分析</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/深度学习/">深度学习</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/爬虫/">爬虫</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/自然语言处理/">自然语言处理</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/easy/" style="font-size: 15px;">easy</a> <a href="/tags/可视化/" style="font-size: 15px;">可视化</a> <a href="/tags/Matlab/" style="font-size: 15px;">Matlab</a> <a href="/tags/Hbase/" style="font-size: 15px;">Hbase</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/无监督/" style="font-size: 15px;">无监督</a> <a href="/tags/R语言/" style="font-size: 15px;">R语言</a> <a href="/tags/监督学习/" style="font-size: 15px;">监督学习</a> <a href="/tags/GAN/" style="font-size: 15px;">GAN</a> <a href="/tags/数据挖掘/" style="font-size: 15px;">数据挖掘</a> <a href="/tags/工作流程/" style="font-size: 15px;">工作流程</a> <a href="/tags/py/" style="font-size: 15px;">py</a> <a href="/tags/数学/" style="font-size: 15px;">数学</a> <a href="/tags/word2vec/" style="font-size: 15px;">word2vec</a> <a href="/tags/BeautifulSoup/" style="font-size: 15px;">BeautifulSoup</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/Hive/" style="font-size: 15px;">Hive</a> <a href="/tags/matplotlib/" style="font-size: 15px;">matplotlib</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/numpy/" style="font-size: 15px;">numpy</a> <a href="/tags/爬虫/" style="font-size: 15px;">爬虫</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/sklearn/" style="font-size: 15px;">sklearn</a> <a href="/tags/深度学习/" style="font-size: 15px;">深度学习</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/16/begining-gan/">Generative Adversarial Nets 对抗生成网络初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/16/semantic-segmentation-papers/">语义分割论文</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/11/git-branch-request/">gitlab分支管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/11/python-unittest/">python-unittest</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/10/tensorflow-model-restore-and-transfer/">TensorFlow的模型恢复与迁移</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/python-Multiprocessing/">python-Multiprocessing</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/update-cudnn/">升级cudnn版本</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/01/how-to-learn-machine-learning/">how to learn machine learning</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/18/gradient-vanishing/">梯度弥散(gradient-vanishing)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/jupyter-key/">jupyter-快捷键</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/u012925804" title="My CSDN" target="_blank">My CSDN</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">老姜工作室.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>